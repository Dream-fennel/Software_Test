@[toc]

# 2.6 初识

## 一、软件测试理论

![img](https://i-blog.csdnimg.cn/img_convert/b19f6757044c6a1414f508041219e303.png)

## 二、软件的生产过程

![img](https://i-blog.csdnimg.cn/img_convert/fd5428a352e2bd44da7931a7aeb19481.png)

客户（需求产生）--->产品经理（需求文档）---->UI设计师（设计效果图）--->研发工程师（研发产品）---->测试工程师（检测软件）--->部署上线

## 三、软件测试概述

什么是软件测试？

利用技术手段，验证软件的是否有问题

## 四、软件测试目的

**降低企业风险，提高用户体验**

提高软件的质量，保证软件的安全，降低软件开发成本；

降低因软件缺陷带来的商业风险；

树立用户对软件的信心。

## 五、软件开发与软件测试的区别？

软件开发：开发人员写代码

软件测试：使用测试软件进行测试

## 六、学习内容

功能测试：功能测试，接口测试，自动化测试，性能测试，车载测试

趋势：两会

学习建议：模仿+思考

主动学习：教会同桌

及时复习：

晚自习：1.自我（感谢+介绍+祝福）2.家乡美

# 2.7 理解

软件测试的工作流程

扩展：公司人员（小公司）

例如：xxx科技有限公司

老板【1】

产品经理（业务员）【3】

研发人员（开发软件的(ui，前端，后端)）【20】

测试人员（检查软件）【3】

运维人员（维护软件的）【2】

研发/测试=8:1

前台，财务，人事

## 一、软件测试的定义

通过手工或者测试工具按照测试方案和流程对被测对象进行功能或性能的检测。从而验证实际结果与预期结果之间是否存在差异。

测试对象：软件的主体功能+使用说明书+配置数据

![img](https://i-blog.csdnimg.cn/img_convert/e3d7c09137c15b3beba5150debece962.png)

## 二、软件和软件测试的生命周期

### 1.软件的生命周期

从无到有，再从有到无的过程

**阶段：从小到大**

![img](https://i-blog.csdnimg.cn/img_convert/00a2d6817c56cc49ac68aa3391f5f3bf.png)

### 2.软件测试的生命周期

需求分析--->测试计划--->测试设计--->测试执行--->测试评估

![image-20250207112142940](https://i-blog.csdnimg.cn/img_convert/47b59bd9209c3730c6a484275e4bd226.png)

## 三、软件测试的原则

- 原则是每个人在行事中所遵循的准则
- 测试只能证明软件存在问题，不能证明不存在问题
- 测试工作要尽早的介入，降低修复成本
- 不能进行穷尽测试，要进行分类测试
- 缺陷存在集群现象，通常大部分BUG发生在一小部分核心模块中；好测试的环境
- 杀虫剂现象，尽量多的测试手段以便发现更多的BUG
- 测试依赖环境，对软件开展测试前应先准备好测试的环境
- 不存在缺陷是谬论

## 四、软件测试分类

按**软件产生的阶段**划分：

单元测试，集成测试，系统测试，验收测试(α，β，γ，UAT)

单元测试：白盒（函数，类）黑盒（窗口，菜单，按钮）

集成测试：模块与模块之间的测试

系统测试：对软件整体（功能，性能等）进行全面测试

验收测试：**α.内测，β.公测，γ.候选版本**，UAT用户测试

按**代码可见度**划分：

黑盒测试（看不见内部），灰盒测试（可见内容有限），白盒测试（完全能看见）

![image-20250207144623707](https://i-blog.csdnimg.cn/img_convert/1b4aa608c4f98229017003c65c4d3a08.png)

按**是否运行**划分：

静态测试：指不实际运行被测软件，而只是静态的检查程序代码、界面或文档中可能存在的错误过程。

动态测试：指实际运行被测程序，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程。

按**测试手段**划分：

人工测试，自动化测试

**其他测试**：

冒烟测试，回归测试，随机测试

冒烟测试：对核心功能**按照全部正确的数据或者流程，对系统进行最基本功能的测试**，保证软件最基本的功能和流程能走通。

**回归测试**：对已修复BUG，再次测试；**软件版本更新/迭代**后，对**老版本的内容再次测试**。

随机测试：1.挑选之前发生严重BUG的地方 2.挑选之前漏测的地方 3.挑核心模块（主业务和关于钱的）

## 五、软件的开发与测试模型

### 1.软件开发模型

瀑布模型

![image-20250207162642069](https://i-blog.csdnimg.cn/img_convert/193a99dd30b3eb754e605cdf95ee8238.png)

- 需求分析---设计---编码---实现---软件测试---完成---维护
- 瀑布模型特点：瀑布模型是一种线性的

**瀑布模型的优缺点**

- 优点：开发的各个阶段比较清晰，当前阶段完成后，只需关注后续阶段；强调早期的计划与需求调研；适合需求稳定的产品。
- 缺点：不适应需求的变化，依赖早期的需求调研；风险延至后期才暴露，失去了及早纠正的机会。
- **改良：在前期一些重要的阶段之间加入了迭代的思想，尽量避免把风险拖至后期。**

### 2.测试模型

#### 1>V模型

![image-20250207162706352](https://i-blog.csdnimg.cn/img_convert/7ee245028bb7ccad46c234e8bd716c1a.png)

需求分析---概要设计---详细设计---编码---单元测试---集成测试---系统测试---验收测试

- 优点：开发的各个阶段比较清晰，当前阶段完成后，只需关注后续阶段；强调早期的计划与需求调研；适合需求稳定的产品。
- 缺点：不适应需求的变化，依赖早期的需求调研；风险延至后期才暴露，失去了及早纠正的机会。
- **改良：在前期一些重要的阶段之间加入了迭代的思想，尽量避免把风险拖至后期。**

#### 2>W模型

开发模型与测试模型合在一起

![image-20250207162741620](https://i-blog.csdnimg.cn/img_convert/b1593e19e3cffc12aa41d99925c910b3.png)

## 六、B/S与C/S架构

### 1.测试考虑

B/S架构（浏览器与服务器）

测试考虑：网站在各种了浏览器能打开

C/S架构（客户端与服务器）

测试考虑：软件在各种手机上都能安装使用

### 2.B/S与C/S架构的区别？

- B/S比C/S架构成本低，升级便利
- 但是C/S架构更安全，更效率

## 七、软件质量模型

ISO：国际标准

![image-20250207172141755](https://i-blog.csdnimg.cn/img_convert/890f1ea5b63bd3f4b98274159f4879fc.png)

例：如何验证某系统质量呢？以微信为例

- 功能性：与需求数量一致，功能正确；
- 性能：响应快、占用资源少；
- 兼容性：不同设备平台正常使用；
- 易用性：用户体验好；
- 安全性：敏感信息无泄密存储有保障；
- 可靠性：持久运行无异常；
- 可移植性：升级迁移数据不丢失；
- 可维护性：异常恢复简单、可扩展功能、升级更新便捷。

## 面试问题

### 你们公司的测试流程能说一下吗？

### 你们公司的验收测试是怎么做的？

三选一：1.去甲方 2.甲方来 3.第三方

### 你能说一下黑盒测试和白盒测试的区别吗？

黑盒测试：重点关注软件的功能以及性能是否满足需求

白盒测试：重点关注代码以及逻辑是否正确

### 你们软件多久迭代一次？迭代后回归测试做多久？

迭代：大版本：2、3个月迭代一次；小版本：1、2周迭代一次

回归测试：大版本十几天；小版本几天。

# 2.8

## 一、测试用例

什么是测试用例？

测试用例（test case）是为测试项目而设计的执行文档

作用：防止漏测，重复测试，实施测试的标准，以便更好的开展测试工作。

## 二、测试用例编写格式（要素）

通常用Excel文档编写，要素由以下八个要素组成：

用例编号、用例标题、测试模块、优先级、前置条件、测试步骤、测试数据、预期结果。

**用例编号**：通常由**项目_模块_编号**组成；

**用例标题**：预期结果（测试点）；

**测试模块**：所属项目或模块/子模块。

**优先级**：表示用例的重要程度或影响力，由高至低依次为1、2、3、4（也有称P0、P1、P2、P3）；

**前置条件**：要执行此条用例，有哪些前置操作；

**测试步骤**：描述操作的步骤；

**测试数据**：操作软件需要的数据，没有可以不填；

**预期结果**：期望达到的结果（唯一性）。

![image-20250208105036020](https://i-blog.csdnimg.cn/img_convert/99bc9a882157663e7f51e0d5005445c3.png)

## 三、缺陷

### 1.缺陷定义

软件在使用过程中存在的任何**问题**都叫软件缺陷，简称Bug。

软件缺陷的存在会导致软件产品在某种程度上**不能满足用户需求**。

### 2.缺陷判定标准

**少功能**：软件未实现需求说明书中明确要求的功能。

**多功能**：软件实现的功能超出了需求说明书指明的范围。

**功能错误**：软件出现了需求说明书中指明不应该出现的错误。

**隐形功能错误**：软件未实现需求说明书中虽未明确指明但应实现的要求。

**不易使用**：软件难以理解，不易使用，运行缓慢，用户体验不好。（隐形功能错误和不易使用，尽量不提）

### 3.缺陷的跟踪流程（缺陷的生命周期）

![image-20250208152448058](https://i-blog.csdnimg.cn/img_convert/44470bb9ca7c091177ceddc3a1069427.png)

**口述**：

我提交BUG，通知开发人员，开发人员会先判断这个BUG是否重复，如果重复则关闭这个缺陷，如果不重复，则判断这个缺陷是否是个BUG，确认这个是BUG后，与开发，项目经理等项目相关人员进行商讨是直接修复还是推迟处理，如果推迟处理，确认推迟处理的日期和版本，如果不能推迟则立即修复，修复之后由我进行复测，如果测试通过则关闭这个BUG，如果测试没有通过则重新提交BUG，由开发人员再次判断。

### 4.缺陷的核心内容

缺陷标题，缺陷的预置条件，缺陷的复现步骤，缺陷的预期结果，缺陷的实际结果，缺陷的严重程度，修复缺陷的优先级，缺陷的附件。

![image-20250208153956955](https://i-blog.csdnimg.cn/img_convert/ccac19390ca88482519b0f3e5a98f73d.png)

### 5.缺陷的严重程度

通常指缺陷对软件质量的破坏程度，即此缺陷的存在将对软件的功能和性能产生怎样的影响。

共分为4级，由高至低依次为1、2、3、4（P0、P1、P2、P3）。

- 1级（P0）致命：死机，非法退出，死循环，数据库发生死锁。

  如：软件死机，意外退出，操作系统崩溃。
- 2级（P1）严重：功能不符，严重计算错误，接口数据错误等。

  如：主要功能失效或未实现。
- 3级（P2）一般：界面或内容错误，异常操作未给出提示等。

  如：非主要功能失效或未实现。
- 4级（P3）轻微：格式不规范，提示窗口文字未采用行业术语等。

  如：某个控件没有对齐，某个标点符号丢失等。
- 5级（P4）建议型（如果有）

### 6.修复缺陷的优先级

**表示处理和修正软件缺陷的先后顺序**。即哪些缺陷需要优先修正，哪些缺陷可以稍后修正。

共分为4级，由高至低依次为1、2、3、4（P0、P1、P2、P3）。

- 1级（P0）紧急：立即修复。如：1天内修复。
- 2级（P1）高级：几天内修复。如：一周内修复。
- 3级（P2）中级：上线前修复。如：此版本上线前修复。
- 4级（P3）低级：时间允许时再修复。如：在不影响软件主要功能使用的前提下，可考虑在后续版本修复。

**一般而言，严重程度高的缺陷修复的优先级也高。但我们还需要注意，有些BUG严重程度低修复的优先级不一定低。**

![image-20250208160040915](https://i-blog.csdnimg.cn/img_convert/28ef60d164322b0ffcd58cebe303c132.png)

### 7.提交缺陷注意事项

![image-20250208163152676](https://i-blog.csdnimg.cn/img_convert/1fe7f240c094e8f43c5d47472c0064e6.png)

### 8.编写缺陷规范

![image-20250208163224000](https://i-blog.csdnimg.cn/img_convert/42ec5bc1b6874c25d1805922de9eb090.png)

### 9.缺陷修改补充说明

- 并不是所有缺陷都要修复；考虑性价比和时间
- 有时市场的压力使得产品最终发行有时间限制；
- 或者测试人员错误理解或者不正确操作引出的缺陷；
- 错误的修改影响的模块较多，带来的风险较大(遗留)；
- 修改性价比太低；
- 缺陷报告中提出的问题很难重现等等，这些原因导致的缺陷会视情况而定。

为什么开发人员会拒绝修改缺陷？

程序员无法重现或者现象难以捕捉；

没有明确的报告以说明重现缺陷的步骤；

程序员无法读懂的缺陷报告；

用户很少使用或者不符合用户使用习惯的操作出错；

由不受信任的测试人员提出。

### 10.缺陷密度计算

进行缺陷密度计算，可有效的进行软件管理。目前行业标准是每一千行代码中存在5个以上Bug。

缺陷总数÷代码行数×1000‰ = 缺陷密度（/KLOC）

如：一个1万行的源程序代码里发现了68个缺陷

则缺陷密度为：6.8/KLOC

计算方式：68÷10000×1000‰=6.8‰

小结：

1、如何描述软件的生命周期？

2、如何描述软件测试的生命周期？

3、软件测试的工作流程是什么？

4、软件测试的定义是什么？

5、软件测试的对象是什么？

6、软件测试的目的是什么？

7、软件测试的原则是什么？

8、软件测试分为哪些类？

9、瀑布模型是什么？如何改良？

10、V模型与W模型是什么？V模型如何改良？

11、B/S架构与C/S架构有什么区别？

12、软件测试的质量标准（特性）是什么？

13、测试用例的要素有哪些？

14、测试用例的作用是什么？

15、什么是缺陷？

16、发现Bug后，你是怎么确认的？

17、缺陷的要素（Bug单）有哪些？

18、缺陷的严重程度以及修复缺陷的优先级怎么划分？

19、缺陷的处理流程（生命周期）？

20、你提交的缺陷开发不认可你怎么办？

21、如何提交一条高质量的Bug？

## 面试问题

### 1、你提交的BUG开发认为不是个BUG，你会怎么做？（你提交的缺陷开发不认可你怎么办？）

首先我会看下开发是在什么情况下认为它不是个BUG，其次我会跟开发核对下需求文档，看是否理解有异（角度不同）；

若开发还是不认可，我会再次把BUG重现步骤的相关截图以及运行日志一并发给开发验证；

实在解决不了我会向经理报风险，通常会在周五下午的周总结会上提出，并解决；若比较紧急，会立即开会解决。

### 2、测试用例的要素有哪些？

用例编号、用例标题、测试模块、优先级、前置条件、测试步骤、测试数据、预期结果。

### 3、发现Bug后，你是怎么确认的？

发现BUG我会先检查是不是环境的问题，然后复现BUG

### 4、缺陷的要素（Bug单）有哪些？

缺陷标题，缺陷的预置条件，缺陷的复现步骤，缺陷的预期结果，缺陷的实际结果，缺陷的严重程度，修复缺陷的优先级，缺陷的附件。

### 5、缺陷的严重程度以及修复缺陷的优先级怎么划分？

### 6、缺陷的处理流程（生命周期）？

### 7、如何提交一条高质量的Bug？

确认，复现，附件（截图，视频等）

自己先确认这是BUG ，然后复现这个BUG，把这个BUG的复现过程写清楚

注意事项：1.一个BUG一个单 2.填写BUG单，要简明，提要

如何提交一条高质量的Bug？

发现bug后我会先核对需求文档，确认bug，在提交bug时，bug的标题要简单明了，bug的复现步骤要符合我们测试的步骤，还有发现bug的环境，以及bug的预期结果和实际结果，如果有相关截图和运行日志一并添加到附件，以及bug的严重程度和修复bug的优先级，以便开发快速定位，一个bug单提交一个bug，以便后期跟踪管理，填写bug单时要简明提要，有助于提高工作效率。

### 8、你一天能写多少条用例？

这个嘛，其实一天能写多少测试用例，真的得看情况。像需求明不明确、业务复不复杂，还有时间紧不紧，这些都会影响我写用例的速度。如果都顺利的话，我一天大概能搞定二三十条高质量的用例吧。

### 9、你一天能执行多少条用例？

这个得看情况。如果测试环境稳定，用例也比较简单的话，那我一天可能能执行个上百条。但要是环境老出问题，或者用例比较复杂，那数量就得少点了。

### 10、如果时间紧急，没时间写用例，你怎么开展工作？

首先我会在工作中做好笔记，整理好测试相关数据，周末加班写测试用例。

### 11、你一天能找几个BUG？

如果测试的系统或应用比较复杂，且存在很多潜在问题，那我可能会找到多一些的BUG。但要是系统比较稳定，或者我主要在做的是回归测试，那找到的BUG数量可能就会少一些。

# 2.9

## 1.计算机基础

计算机（PC）：硬件+软件

硬件：CPU、内存、磁盘、主板、输入设备、输出设备等

软件：系统软件、应用软件

建议：书写用例，及时保存

五大部件：运算器，控制器，存储器，输入设备，输出设备。

符号扩展，零扩展

![image-20250209105224657](https://i-blog.csdnimg.cn/img_convert/a7ca4955f0c3633419f5b527877d657a.png)

测试工作中，考虑对文档（图片，音频，视频）大小的测试。

截图：start snippingtool 文件后缀名为bat

常见浏览器：IE（edge），谷歌，火狐，苹果

测试工作中，对应网站的兼容性，考虑以上几个常用浏览器，其他浏览器，内核都与上述浏览器相同。

查看丢失率，和返回时间，来判断网络状态

## 2.背诵

### Apache、Tomcat、Redis、MySQL协同工作流程图描述

1.客户端请求（Client Request）

客户端向Web服务器（Apache）发送HTTP请求。

2.Apache处理请求

Apache接收HTTP请求，并判断请求类型？

如果是静态资源请求（如HTML、CSS、图片等），直接从文件系统中获取并返回给客户端。

如果是动态内容请求或需要Tomcat处理的请求（如Java Web应用程序），将请求转发给Tomcat。

3.Tomcat处理请求

Tomcat接收来自Apache的请求，解析请求，并调用相应的Java Servlet或JSP页面进行处理。

在处理过程中，如果需要从数据库中读取数据：首先尝试从Redis缓存中读取。

如果Redis中没有所需数据，则连接到MySQL数据库进行查询。将查询结果返回给Tomcat。

4.数据库操作（MySQL）

如果Tomcat需要从数据库中读取数据，则通过JDBC或其他数据库连接技术连接到MySQL数据库。执行SQL查询语句，并将结果返回给Tomcat。

5.响应客户端（Client Response）

Tomcat将处理结果返回给Apache，Apache将结果发送给客户端。

# 2.10

## 一、AI助力需求分析

帮助我们更好的理解需求，找去需求中的不足之处。

## 二、AI助力测试计划

### 1.测试计划内容有什么？

项目概述、测试目的、测试标准、参考文档、测试对象、测试范围、

测试环境、测试策略、任务分配、用例管理、缺陷管理、风险控制、

应急措施、质量评估标准...

公司场景：

测试计划通常由测试经理（测试负责人）来编写的。

### 2.测试计划和测试策略的有什么区别？

测试计划是由经理编写的，含有测试策略（大概）

详细的测试策略是由测试人员编写的

测试策略是对测试计划中的一环的详细补充

### 3.测试计划书，指令模板

角色：你是一名测试工程师。 指示：根据以下需求，编写测试计划与方案。

需求：（需求文档）

要求：

1、方案中包含测试策略，风险评估；

2、测试周期15天；

3、测试人员6人。

## 三、AI助力测试用例设计

测试编号、测试标题、测试模块、优先级、前置条件、测试步骤、测试数据、预期结果

帮助我们提取测试点，编写测试用例

**指令**：根据需求提取测试点，再根据测试点写测试用例

### 1.编写用例步骤

第一步：分析需求

第二步：根据需求提取测试点（测试点：要测的地方）

第三步：根据测试点写用例

## 四、AI助力测试用例执行

帮助我们生成测试环境部署文档、脚本、冒烟测试、缺陷预测

---

请对以下需求生成冒烟测试用例需求：

1、账号：必填，已经注册手机号或邮箱

2、密码：必填，注册账号的密码

3、验证码：正确且未过期

输入:参考用例8大要素格式

输出:使用excel表格形式

## 五、AI助力测试评估

### 1.测试计划内容由哪些？

测试目标、测试范围、测试策略、测试资源、测试进度、风险管理、测试环境、测试数据、评估准则

### 2.测试策略内容有哪些？

测试类型、测试方法、测试工具、测试优先级、环境配置

### 3.测试报告内容有什么？（总体，一般由测试经理写）

测试环境、测试方法、测试工具、测试人员、测试时间、缺陷汇总、缺陷分析、风险预估、测试总结......

公司场景：

对于整个项目的测试报告，通常由测试经理编写，对于单个模块的测试报告，通常谁测试谁来编写。

## 面试

### 1.你写过测试计划书吗？

回答：写过，在一次重要的项目中，由于测试经理需要协调整体测试工作，他让我协助他准备测试计划书。

### 2.你写过测试报告吗？（个人，测试人员）

测试环境、测试方法、测试工具、用例数量、执行数量、用例执行率、缺陷数量、修复数量、缺陷修复率、遗留问题备注

# 2.13

## 一、禅道是什么

软件：管理项目的

## 二、部署禅道

警告：在公司无需个人电脑部署

公司会给你访问禅道的地址以及用户名和密码

## 三、管理禅道

只有管理员才有权限管理，个人用户无权限

课堂练习：

测试工程师：用户名，自己名字的拼音，密码：123456

## 四、使用禅道

常见操作流程：

1.导出用例模板

2.导入测试用例

3.执行测试用例

4.提交BUG

5.关闭BUG

写用例

- 用例少：直接在禅道中写即可
- 用例多：导出用例模板---->在模板中写用例---->把用例导入禅道
- 注意事项：建用例时，注意项s目名称；下载用例模板时，注意不要出现乱码；
- 导入用例时，该用例文档不能被占用
- 导入用例时，只能导入10条，什么原因？可能是权限问题
- 导入用例，一定到检查仔细，导入的用例一旦出错，无法删除，只能一条条修改

执行用例

测试结果：N/A：表示不存在。阻塞：这个用例无法执行下去，可能是外部依赖环境没有解决，或者其他的原因。

升级浏览器。

提交BUG

BUG单填写完整，尽量自己先按照描述复现BUG。

验证BUG

关闭BUG

## 面试

## 1.你们公司用什么管理项目的？（用什么管理用例的？）

禅道

## 2.那你能说下禅道怎么用的吗？

写用例、执行用例、提交BUG

# 2.14

B2C：商家与消费者

## 一、测试思想

先测什么？（业务流程）再测什么?（单功能或页面）

先冒烟测试后全面测试

冒烟测试：**对核心功能按照全部正确的数据或者流程，对系统进行最基本功能的测试**，保证软件最基本的功能和流程能走通。

eg：面对一个项目时（京东购物网站）？

先测：能否购物成功？（冒烟测试）

再测：单个功能是否OK，或单个页面内容是否OK。（全面测试）

## 二、项目测试流程

![image-20250214094511102](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250214094511102.png)

## 三、业务流程测试

场景法：从不同的测试路径到达目的地。基本流+备选流

**什么时候使用场景法？**

拿到任务后，先关注业务流程能否正确实现

先正向（基本流），再反向（备选流）

![image-20250214095522027](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250214095522027.png)

## 四、场景法设计测试用例的步骤

第一步：构造基本流和备选流；（使用流程图）

第二步：根据基本流和备选流构造场景；（组合，搭配）

第三步：根据场景设计测试用例；（注意先后顺序，先正向后反向）

第四步：对每个测试用补充必要的测试数据（如：等价类边界值方法细化测试数据）。

## 五、流程图的学习

椭圆形、圆角矩形：开始/结束，表示流程的开始/结束。

箭头：路径，表示流程方向。

菱形：判断，表示对某个条件做判断。

矩形：处理，表示执行某项工作。

平行四边形：数据，表示数据的输入/输出。

# 2.15

![4](https://raw.githubusercontent.com/Dream-fennel/image-host/image/4.png)

1.客户提出需求，产品经理接收需求并开始处理。产品经理整理需求，形成需求计划。产品经理建立产品，并将需求与产品关联。项目经理根据关联的产品建立项目。项目经理创建项目需求列表

2.**任务分解**

- 开发团队将项目需求分解为具体的项目任务列表。

用例分解：

- 测试团队根据项目任务列表创建用例列表。

3.**开发团队工作**

- 开发团队根据项目任务列表进行开发工作。

测试团队工作：

- 测试团队根据用例列表进行测试。

4.**创建build和提交测试**：（创建build可以理解为将源代码打包）

- 开发完成后，创建build并提交给测试团队。

5.**测试通过与否**：

- 如果测试通过，进入下一步；如果测试不通过，提交bug。

6.**创建发布**：

- 测试通过后，创建发布版本。

**交付物和总结会议**：

- 产品被交付给客户。
- 召开总结会议，形成改进计划。

## 一、单功能测试

考虑角度?

长度，规则，类型（数字、汉字、字母、符号、空白），

是否可重复？是否区分大小写等等。

![img](https://raw.githubusercontent.com/Dream-fennel/image-host/image/wps1.jpg)

等价类通常解决的时输入框的数据类型。

边界值通常解决的时输入框的长度限制。

通常我们测试工作中，面对输入框时，大概率使用等价类结合边界值一起测试。

### 1.划分等价类

把输入的数据分类（中文、英文、数字、符号）

### 2.怎么划分呢？

有效等价类：满足需求（程序能接受）

无效等价类：不满足需求（程序不能接受）

### 3.什么情况下使用划分等价类

通常有输入框的情况下使用该方法

### 4.设计用例原则

一条有效的等价测试用例，应尽量覆盖多个有效测试点

一条无效的等价测试用例，只覆盖一个无效测试点

### 5.划分边界值

把输入的数据划分下边界。（长度限制）

### 6.什么情况下使用划分边界值法呢？

有效边界值：满足需求（程序能接受）

无效边界值：不满足需求（程序不能接受）

### 7.边界范围节点

选取正好等于、刚好大于、刚好小于边界的值作为测试数据。

上点：边界上的点（正好等于）

距离上点最近的点（刚好大于、刚好小于）

内点：范围内的点（区间范围内的点）

![image-20250215161850971](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250215161850971.png)

**边界值优化：7个优化为5个点。**

上点：必选（不考虑区间开闭）

内点：必选（建议选中中间范围）

离点：**开内闭外**（考虑区间开闭，建议开区间选择内部离点，闭区间选择外部离点）

心得：前三后三加中1，去掉重复的有效就是优化

### 8.等价类与边界值的组合

**步骤：**

1、分析需求

2、划分边界值和等价类

3、提取测试点

4、编写测试用

**注意事项**：提取测试点时

有效：有效边界值 + 有效等价类组合

无效：

无效边界值 + 有效等价类组合

有效边界值 + 无效等价类组合

**组合心得**：有效取（等价类和边界值中）最多的，无效有一条算一条

原则：一条有效等价类测试用例，尽量覆盖多个有效测试点

# 2.16

## 1.判定表（决策表）

表达多条件的逻辑组合工具（表格）。

## 2.什么情况下使用判定表？

多条件组合。

## 3.判定表组成？

条件桩、动作桩，条件项、动作项

## 4.如何计算有几条规则（几种组合情况）

几个条件就是几次方

每个取值条件为基值

## 5.无关条件

动作与某个条件的取值无关

## 6.错误推断法（错误猜测法）

经验、知识、直觉

## 7.什么时候用？

建议用例整理完后。

## 8.学了那些方法？

各种方法的使用场景

场景法：测业务流程

划分等价类：输入框

划分边界值法：对长度内容有限制

判断表法：多条件组合

错误推断法。

思考：什么情况？用什么方法？怎么用的？

## 面试

### 1.你怎么写用例的？

### 2.你设计用例时常用的测试用例设计方法有哪些？

参考答案（自述）：

我拿到需求后，会根据需求文档的描述，使用场景法把整体的业务流程先梳理出来；

若是碰到输入框的地方我会使用划分等价类法把可能输入的数据做个分类，以此来确定有效等价类与无效等价类。

若是对于输入的内容有长度限制，我会再结合划分边界值法区分下有效边界值和无效边界值；

如果有多个条件组合时我会用判定表法把每种组合情况都罗列出来。

最后我还会根据错误推断法看看是否还有遗漏的测试点或者容易出错的地方来完善测试用例。

### 3.用例评审通过的标准?

对需求的覆盖率：100%，对测试场景的覆盖率：95%（以上的随便说一个）

如果不细问则只回答需求的覆盖率，再进行深问的时候再回答对场景的覆盖率

### 4.如何保障你写的用例能达到公司标准？

回答，写用例的步骤即可。

## 扩展：测日期

需求：

在程序中输入一个时间，包含年、月、日，

程序会输出第二天的年、月、日。

![img](https://raw.githubusercontent.com/Dream-fennel/image-host/image/wps2.jpg)

![img](https://raw.githubusercontent.com/Dream-fennel/image-host/image/wps3.jpg)

# 2.18

## 面试

## 测试用例练习

圆珠笔

水杯

电梯

微信发红包

163邮箱注册

微信发朋友圈、点赞、评论

微信、支付宝扫码支付

抖音直播、点赞、评论

三角形

淘宝购物车

ATM取款机

# 2.19

性能测试工具：https:/ /[www.pgyer.com/solopi](www.pgyer.com/solopi)

# 面试

### 1.软件什么时候上线？

（通常选择周一到周四的晚上）

### 2.软件发布策略？

（灰度发布）

![image-20250219100135807](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250219100135807.png)

综合以上两点，目的就是在软件上线时，万一出现问题尽量降低受影响的用户数量。

### 3.你们公司有几套环境？

开发环境，测试环境，线上环境（生产环境），预生产环境（联调环境）。

### 4.APP专项测试你都测那些？

安装成功，升级成功，卸载成功，兼容，push消息推送，交叉推送，用户体验

### 5.APP性能测试你都测那些

CPU，内存，流量，电量，流畅度，启动时间...

### 6.APP端与Web端测试的区别？（面试题90%以上）

**在Web端与APP端，架构不同**

web项目，B/S架构，基于浏览器的；web测试更新了服务器端，用户只需要刷新以下网页即可。 app项目，C/S架构；app 更新，则需要更新客户端

Web端与APP端的功能测试都是相同的。非功能测试有以下不同：

**1.兼容方面**

Web端的兼容性测试是对谷歌、火狐、IE、苹果浏览器的测试，APP端是对不同的系统进行测试，如鸿蒙、安卓、苹果。

APP端还需要考虑网络（2G/3G/4G/5G/WIFI）、软件（例如：支付宝应用不冲突）、硬件（与音量键应用不冲突）的兼容。

**2.在APP性能测试方面**

CPU（不能长时间占用CPU90%以上），内存（不能出现大幅增长），流量，电量，流畅度（帧率建议24帧以上），启动时间...

**3.相于 Wed 项目，APP有专项测试**

安装、更新、卸载 安装：需考虑安装时的中断、弱网、安装后删除安装文件等情况 卸载：需考虑 卸载后是否删除app相关的文件 更新：需考虑临近版本、跨版本、升级提醒（非WIFI提醒）

push消息推送

接收成功，则需要考虑，接收的内容，时机，频率；是否能拒绝接收成功。

交叉推送时APP能否正常运行（如切换计算器应用）。

用户体验方面

页面字体、图片、颜色与UI 设计；菜单层级最好不超过3步，功能的操作步骤不超过5步

### 7.APP性能测试你怎么测的？

在进行APP性能测试时，我主要关注响应时间、资源占用、流畅度、网络性能以及稳定性等关键指标。 首先，我会使用自动化测试工具来模拟用户操作，收集APP在不同场景下的响应时间数据，确保APP能够快速响应用户请求。 其次，我会分析APP在运行过程中对CPU、内存等系统资源的占用情况，找出可能的性能瓶颈，并优化代码和资源管理策略。 同时，我也会关注APP的流畅度表现，通过监测帧率（FPS）等指标，确保APP在滑动、动画等交互操作中保持流畅无卡顿。 此外，网络性能测试也是必不可少的一环。我会在不同网络环境下测试APP的数据传输效率和网络请求响应时间，确保APP在网络条件不佳时也能提供稳定的服务。 最后，我会进行稳定性测试，模拟高并发、大数据量等极端情况，验证APP的健壮性和可靠性。 在测试过程中，我会使用专业的性能测试工具，来监测和分析APP的性能数据。同时，我也会结合人工测试，观察并记录APP在实际使用中的性能表现。通过这些测试方法，我能够全面评估APP的性能水平，并为后续的优化和改进提供有力的数据支持。

常识：

APP的安装包通常是xxx.apk类型的，电脑上的安装包通常是xxx.exe类型的

# 2.20 Mysql的学习

如何有逻辑的描述二者区别？ 先说：分别是什么？ 再说：二者有哪些相同点？ 最后：二者有哪些不同点？

## 超级记忆术

1.捂着耳朵念

2.海马体记忆法（晚上睡觉前15分钟快速念几遍，早上醒来立即回忆）

3.左右脑结合法（记时握紧右手，忆时握紧左手）

数据表明：

念7遍，才能熟悉内容；

念21遍，才能短期记住内容；

念93遍，才能在一个相对长时间内记住内容。

## 1.如何把Mysql学会？

解题思路（占80%）

语法（占20%）

## 2.什么是数据库？

存储数据的仓库

## 3.什么是数据？

文字，图片，音频，视频...

## 4.数据库的特点？

永久存储，数据共享...

## 5.数据库分为：

关系型数据库：Mysql、Oracle..

非关系型数据库：MongDB、DB2

**扩展：Mysql和Oracle的区别？**

## 6.SQL语言是操作关系型数据库的编程语言。

## 7.SQL语言分类

常见：

DQL：数据查询语言

DML：数据操作语言

DDL：数据库定义语言

## 8.Mysql的特点？

开源，免费，体积小，易安装，使用广泛...

思考：自己电脑上有几个MySQL数据库系统？

3个：禅道，tpshop项目，自己安装的

禅道集成环境的Mysql，端口：3306账号：root 密码无

tpshop项目继承环境的MySQL，端口：3306账号：root密码root

自己安装的Mysql，端口：3309密码：123456

## 9.SQL通用语法

SQL语句已‘;‘号结尾，（MySQL中代码不区分大小写）

不想被程序执行的内容，可以加注释；

加注释的方式有两种；

单行注释 用''--'' 或者”#“（'#'为MySQL语句特有的）

多行注释使用”/*“开头 “*/”结尾

SQLyog注释快捷键

Ctrl+Shift+C 注释 SQL 窗口选择内容 Ctrl+Shift+R 从选择内容删除注释

### 公司场景

管理员(运维/开发)给小明数据库的相关信息，如: 172.25.123.66:3308 xiaoming abc123456 小明打开SQLyog或者Navicat，新建连接， 把：172.25.123.66填入到主机地址栏中 把：3306填入到端口号栏中， 把：xiaoming填入到用户名栏中 把：abc123456填入到密码栏中， 最后测试连接，成功即可 失败需要检查信息是否正确? 或者考虑MySQL服务是否开启?

## 10.单表查询语法


| select   | 字段列表       |
| :--------- | :--------------- |
| from     | 表名           |
| where    | 条件列表       |
| group by | 分组字段列表   |
| having   | 分组后条件列表 |
| order by | 排序字段列表   |
| limit    | 分页参数       |
| distinct | 去重           |
| as       | 起别名         |

总结: select 后面跟字段(查询内容) 字段与字段之间用逗号隔开，最后一个不加逗号 后面跟表名(数据来源) from SQL语句以分号结束。 SQL语句中出现字符串，则必须加引号。 as 起别名 distinct 去重

```sql
/*
多行注释
;英文分号结尾
DQL:数组查询语言
select
from
where
group by
having
order by
limit

select * from students;
select name from students;
select name,sex,mobile from students;
select name as 姓名,sex as 性别 from students;
select distinct age from students;
select * from class;
select name from class;
*/
#单行注释
-- 单行注释
SELECT 123,666;
SELECT '好好学习吧';
SELECT 1111;
SELECT NAME AS 姓名 ,sex AS 性别
FROM students;
SELECT *
FROM students;

SELECT DISTINCT age
FROM students;
SELECT age
FROM students;
```

# 2.21

## 练习

syntax：语法

and的优先级高于or

```sql
/*第二天
#第一步：确定查询内容（）
#第二步：确认表明（）
#第三步：确认筛选条件（）

条件查询
查询符合筛选条件的内容
语法：
select 字段列表
from 表名
where 筛选条件
注意：常见的筛选条件有比较筛选和逻辑筛选。

比较筛选：
= > >= < <= !=

like '通配符'  像...s一样
通配符：'%'匹配任意多个任意字符；'_' 匹配任意一个字符。
转义字符：'\'把'\'后面的通配符转义为普通字符
in (值1，值2，...)在...里面
between ... and ...  从...到...
<=>  安全等于（可以处理空值）
is null 处理空值

逻辑运算符：
and：并且（多个条件，同时成立）
or：或（多个条件，任意一个成立）
not：非（取反的意思）
*/

SELECT NAME,mobile
FROM students
WHERE NAME ='王小明';
#第一步：查询学生信息
#第二步：学生表
#第三步：年龄为23
SELECT *
FROM students
WHERE age =23;

SELECT *
FROM students
WHERE age > (
    SELECT age
    FROM students
    WHERE NAME = '刘星');
#第一步：查询学生信息
#第二步：学生表
#第三步：年龄小于23
SELECT *
FROM students
WHERE age <23;
#第一步：查询学生信息
#第二步：学生表
#第三步：年龄大于23
SELECT *
FROM students
WHERE age >23;
#第一步：查询学生信息
#第二步：学生表
#第三步：年龄不等于23
SELECT *
FROM students
WHERE age != 23;
#第一步：查询学生信息
#第二步：学生表
#第三步：姓王
SELECT *
FROM students
WHERE NAME LIKE '王%';
#第一步：查询学生信息
#第二步：学生表
#第三步：手机号包含7
SELECT *
FROM students
WHERE mobile LIKE '%7%';
#第一步：查询学生信息
#第二步：学生表
#第三步：手机号9结尾
SELECT *
FROM students
WHERE mobile LIKE '%9';

#查询手机号为空的学生信息
#第一步：查询学生信息
#第二步：学生表
#第三步：手机号为空
SELECT *
FROM students
WHERE mobile IS NULL;

#查询手机号不为空的学生信息
#第一步：查询学生信息
#第二步：学生表
#第三步：手机号不为空
SELECT *
FROM students
#WHERE mobile is not NULL;
WHERE NOT mobile IS NULL;

/*
筛选情景
一个条件，一个值:（年龄23)
一个条件，多个值：
多个条件，每个条件一个条件一个值：
多个条件，每个条件多个值
*/

#第一步：查询学生信息
#第二步：学生表
#第三步：年龄23的男生
SELECT *
FROM students
WHERE age = 23 AND sex='女';


#第一步：查询学生信息
#第二步：学生表
#第三步：年龄2班的女生
SELECT *
FROM students
WHERE classid =2 AND sex='女';

#第一步：查询学生信息
#第二步：学生表
#第三步：年龄23或25
SELECT *
FROM students
-- WHERE age =23 or age =25;
WHERE age IN (23,25);

#第一步：查询学生信息
#第二步：学生表
#第三步：年龄大于23或手机号码9结尾
SELECT *
FROM students
WHERE age >23 OR mobile LIKE '%9';

#第一步：查询学生信息
#第二步：学生表
#第三步：年龄大于22到25
SELECT *
FROM students
WHERE age BETWEEN 22 AND 25;

#查询性别为男或女，并且年龄为22岁的学生信息
SELECT *
FROM students
WHERE (sex = '男' OR sex = '女') AND age = 22;

SELECT *
FROM students
#会先执行and再执行or，因为and的优先级高于or
WHERE sex = '男' OR sex = '女' AND age = 22;
```

## 1.聚合函数


| sum()   | 求和                     |
| :-------- | :------------------------- |
| avg()   | 求平均值                 |
| max()   | 求最大值                 |
| min()   | 求最小值                 |
| count() | 统计数量（按行统计数量） |

聚合函数语法：

```sql
select 聚合函数（字段列表）
from 表名;
```

==注意事项：==

**聚合函数不对null值进行运算**

**聚合函数不能在where命令中使用**

```sql
#查询学生的年龄总和
SELECT SUM(age)
FROM students;
#去重之后求和
SELECT SUM(DISTINCT age)
FROM students;
#查询学生的平均年龄
SELECT AVG(age)
FROM students;
#查询学生的最大年龄
SELECT MAX(age)
FROM students;
#查询学生的最小年龄
SELECT MIN(age)
FROM students;

#查询学生人数
SELECT  COUNT(*)
FROM students;

#查询有手机号的学生人数
-- select count(id)
-- from students
-- where id in(
--  select id
--  from students
--  where mobile is not null);

-- select count(*)
-- from students
-- where mobile is not null;

#聚合函数不对NULL值进行统计
SELECT mobile
FROM students;
SELECT COUNT(mobile)
FROM students;

/*面试题
COUNT(*)与COUNT(字段)的区别
* 表示所有字段（students 表中有8列）
count(*)时把8列看做一个整体（入参）
count(*)时，不过滤NULL值（把某列中的NULL值也计算在内）
count(字段)时，过滤NULL值（把某列中的NULL值也计算在内）
*/ 
#查询没有手机号的学生人数
-- SELECT COUNT(id)
-- FROM students
-- WHERE id IN(
--  SELECT id
--  FROM students
--  WHERE mobile IS NULL);

SELECT COUNT(*)
FROM students
WHERE mobile IS NULL;

#查询学生表的班级数量
SELECT DISTINCT classid
FROM students;
SELECT COUNT(DISTINCT classid)
FROM students;
```

常见数据库报错提示:
库出错：关键字 database(库)
表出错：关键字 table(表)
列出错：关键字 column(列)
语法出错：关键字 error(错误) near(附近)

# 面试

1.COUNT(*)与COUNT(字段)的区别？

” * “表示所有字段（students 表中有8列）

count(*)时把8列看做一个整体（入参），只要有一列不为空，改行就会计算在内

**count(\*)时，不过滤NULL值（只要有一列值不为空，该行就会计算在内）**

**count(字段)时，过滤NULL值（只统计该列中有值的行数，null值不计算在内）**

## 总结

SOL：操作关系型数据库的编程语言。
SQL语言分类
DQL：数据查询语言；(查数据)
DML：数据操作语言；(对数据进行增、删、改)
DDL：数据库定义语言，(对库、表、列的结构进行增、删、改)
DQL查询语法：
select  查询内容
字段(列名);
字段与字段之间用逗号隔开;
distinct 对该字段查询的结果数据去重;
函数（聚合函数）：sum,avg,max,min,count)
聚合函数过滤(不计算)Nu11值。**聚合函数不能在where命令中使用**
from       数据来源
表名
where     筛选条件
比较运算(一个条件用比较运算)

```
=< < > >= = =! ，like  % _，is null ；
```


(一个值）in(vl,v2,...)，between...and..(多个值)
逻辑运算(多个条件用逻辑运算连接每个条件)
and	并且(多个条件同时满足)
Or	或者(有一个满足即可)
not	非(取反)

# 2.24

```sql
# 分析思路
# 第一步：确定查询内容（）
# 第二步：确定数据源（）
# 第三步：确定原始数据筛选条件（）
# 第四步：确定分组字段（）
# 第五步：确定分组后统计的数据筛选条件（）
# 第六步：确定排序字段以及排序方式（）
# 第七步：确定查询条数（）
```

# 一、group by

分组查询：（为什么要分组？）
为了方便统计数据

## 语法

select 分组字段，聚合函数
from 表名
[where 对原始数据的筛选]
group by 分组字段
having 对分组后的数据筛选
group by 把字段内相同的数据分到一个组中。
having  通常筛选的是聚合函数。（聚合函数不能用在where后面）

## 1.判断是否用分组

**关键字+聚合函数**
关键字：每个，哪个，各个等有区分的意思
聚合函数：SUM,AVG,MAX,MIN,COUNT

## 2.判断分组字段？

通常分关键字后面的字段。

## 3.如何避免数据失真？

建议查询的结果是分组字段或聚合函数：
**未分组的字段不建议查询，有可能会导致数据（查询结果）失真。**
分组字段：GROUP BY 命令后的字段

## 练习

```sql
# 分析思路
# 第一步：确定查询内容（）
# 第二步：确定数据源（）
# 第三步：确定原始数据筛选条件（）
# 第四步：确定分组字段（）
# 第五步：确定分组后统计的数据筛选条件（）
# 第六步：确定排序字段以及排序方式（）
# 第七步：确定查询条数（）
SELECT	sex,COUNT(id)
FROM students
GROUP BY sex;

SELECT	age,COUNT(id) AS 人数
FROM students
GROUP BY age;

-- 查询每个班级的学生人数
-- 第一步：确认查询内容：人数
-- 第二步：确认数据源：学生表
-- 第三步：确实筛选条件：无
-- 第四步：确认分组字段：班级
SELECT	classid,COUNT(id) AS 人数
FROM students
GROUP BY classid;
-- 查询每个班级的学生姓名
-- 第一步：确认查询内容：姓名
-- 第二步：确认数据源：学生表
-- 第三步：确实筛选条件：无
-- 第四步：确认分组字段：班级
SELECT classid,NAME
FROM students
GROUP BY classid; #数据失真

#查询学生人数大于2的班级编号及人数
# 分析思路
# 第一步：确定查询内容（班级编号，人数）
# 第二步：确定数据源（students）
# 第三步：确定原始数据筛选条件（无）
# 第四步：确定分组字段（班级编号）
# 第五步：确定分组后统计的数据筛选条件（学生人数大于2）
SELECT classid,COUNT(id)
FROM students
GROUP BY classid
HAVING COUNT(id)>2;

#having 不能单独出现，必须跟在group by后面
1.必须要分组
2.分哪个字段？  关键字后面的字段：（无关键字

#查询学生年龄大于23的班级编号及人数
SELECT classid,COUNT(id)
FROM students
WHERE age>23
GROUP BY classid;

SELECT classid,COUNT(id)
FROM students
WHERE COUNT(id)>2
GROUP BY classid;
```

# 二、order by

排序查询
方便对查询的结果进行查看
语法：
SELECT 字段列表
FROM 数据源
ORDER BY 字段1 排序方式,字段2 排序方式,...
排序方式 ASC 升序 ；DESC 降序

## 练习

```sql
-- 排序查询
-- 方便对查询的结果进行查看
-- 语法：
-- select 字段列表
-- from 数据源
-- order by 字段1 排序方式,字段2 排序方式,...
-- 排序方式 ASC 升序 ；DESC 降序
-- 若确实排序方式，则默认为升序
-- 多个字段排序时，需要用逗号隔开；
-- 先排前一个字段，若值相同，再对后一个字段进行排序

#查询学生的年龄，要求：按照年龄升序/降序
# 分析思路
# 第一步：确定查询内容（年龄）
# 第二步：确定数据源（学生表）
# 第三步：确定原始数据筛选条件（无）
# 第四步：确定分组字段（无）
# 第五步：确定分组后统计的数据筛选条件（无）
# 第六步：确定排序字段以及排序方式（降序）
SELECT age
FROM students
ORDER BY age DESC;

#查询学生的年龄和地址编号，
#要求按照年龄升序，地址编号降序
SELECT locationid,age
FROM students
ORDER BY locationid DESC,age;

#查询每个班级的男生人数
#人数按降序
# 分析思路
# 第一步：确定查询内容（人数）
# 第二步：确定数据源（学生表）
# 第三步：确定原始数据筛选条件（男生）
# 第四步：确定分组字段（班级编号）
# 第五步：确定分组后统计的数据筛选条件（无）
# 第六步：确定排序字段以及排序方式（降序）
SELECT COUNT(id)
FROM students
WHERE sex = '男'
GROUP BY classid
ORDER BY COUNT(id) DESC;

#AS可以省略
SELECT COUNT(id) 人数
FROM students
WHERE sex = '男'
GROUP BY classid
ORDER BY 人数 DESC;
```

# 三、limit分页查询

## 语法

select 字段列表
from 数据源
limit [offset,]size;
offset 表示偏移量（起始位置为0）
size   表示查询的函数（几行）
limit 后可以跟一个值，也可以跟两个值；
跟一个值：表示查询几条数据；
跟两个值：前值表示几条不要，后值表示查询的条数；

```sql
#查询年龄最小的学生信息
SELECT *
FROM students
ORDER BY age
LIMIT 1;

SELECT *
FROM students
ORDER BY age
LIMIT 0,1;

#查询地址编号最大的学生信息
SELECT *
FROM students
ORDER BY locationid DESC
LIMIT 1;

#查询人数最多的班级以及人数
#思路：先查询每个班级的人数
#再把每个班级的人数降序排序
SELECT classid,COUNT(id)
FROM students
GROUP BY classid
ORDER BY COUNT(id) DESC
LIMIT 1;

#查询第二到第四位的学生信息
SELECT *
FROM students
ORDER BY id
LIMIT 1,3;

#查询学生姓名以及所在的班级名称（多表查询）
SELECT students.name,class.name
FROM class,students
WHERE students.classid=class.id;
```

## 总结

limit后可以跟1个值或2个值。
1个值时，表示查询的条数
2个值时，判断时条数还是页数？
条数：前值=小值-1，后值=大值-小值+1
页数：前值=（页数-1）* 每项条数，后值=每页条数。

# 面试

## 1. where和having的根本区别

语法不同：

where跟在group by 命令前面，是分组之前进行过滤，不满足where条件，不参与分组；

having 跟在gruop by 命令后面，是分组之后对结果进行过滤

判断条件不同：

where 不能对聚合函数进行过滤，而having 可以

```sql
-- where 与 having 的区别？
-- 1.语法不同：
-- where 书写在group by前；
-- having 书写在group by后；
-- 2.筛选的数据对象不同：
-- where 筛选的是原始数据：（不能筛选聚合函数）
-- having 筛选的是分组后统计的数据
```

# 2.25

![image-20250225155441722](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250225155441722.png)

## 1.等值连接

```sql
语法格式：
select * 
from 表A [inner] join 表B 
on 表A.列=表B.列;
```

**执行顺序**：先执行on再执行join

## 2.非等值连接

**查询的结果为表1里某字段里的数据在表2里对应字段的等级范围。**

```sql
/* 
语法格式: 
select * 
from 表A [inner]  join表B 
On  表A.列 bewteen 表B.列 and 表B.列; 
*/
#查询学生的年龄以及年龄称呼
SELECT age,level.name
FROM students INNER JOIN LEVEL
ON age BETWEEN low_age AND high_age;
```

## 3.外连接

==外连接不但返回符合连接和查询条件的数据行，还返回不符合连接条件，但符合查询条件的数据行。==

```sql
外连接分三类：
左外连接 ：LEFT OUTER JOIN
右外连接 ：RIGHT OUTER JOIN
全外连接 ：FULL OUTER JOIN 
```

### 3.1左外连接

```sql
语法格式：
select * 
from 表A left [outer] join 表B
on 表A.列=表B.列;
```

![image-20250225154101480](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250225154101480.png)

### 3.2右外连接

```sql
语法格式：
select * 
from 表A right [outer] join 表B
on 表A.列=表B.列;
```

![image-20250225154305044](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250225154305044.png)

==注意事项：==
结果集：主表的全部内容+从表中匹配到的内容+从表中未匹配到的内容以null补全。
外连接中表的顺序是固定的，不可以随意调换。
左外：left outer join 左边是主表，右边是从表；
右外：right outer join 右边是主表，左边是从表。

### 3.3全外连接

```sql
语法格式：
select * 
from 表A full [outer] join 表B 
on 表A.列=表B.列；
```

![image-20250225154411316](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250225154411316.png)

注意事项：
结果集：A与B的交集部分+A中有但是B中没有的以NULL补全+B中有但是A中没有的以NULL补全；
**由于MySQL5.7版本不支持全外连接语法**，在此我们使用关联查询模拟全外连接结果。

```sql
#语法格式： 
select * from 表A left [outer] join 表B on 表A.列=表B.列
union
select * from 表A right [outer] join 表B on 表A.列=表B.列;
/*
注意：执行是2条SQL一起执行。 
A表 与 B表 的位置固定不变；
先用 左外连接 （A表主表，B表从表）匹配一条sql； 
用 union 把两个表连起来；
再用 右外连接 （A表从表，B表主表）匹配一条sql； 
最后把两条sql一起执行，显示结果与全外链接结果一样。 
*/
```

## 4.交叉连接

==结果是笛卡尔积（缺少连表条件导致）。==

```sql
#语法格式:
select  *
from 表1 cross  join表2； 
```

## 5.分析使用场景

1、如果查询结果是两个表的交集部分，等值连接；
2、如果查询结果是一个表A的数据+另外一个表B的匹配的数据，使用左外右外连接都可；
3、如果查询结果是一个表A中有但是另外一个表B中没有的数据（不完全匹配），使用左外右外连接都可；
4、如果查询结果是A表与B表的交集部分+A表有B表没有的数据+A表没有B表有的数据，使用全外连接；
判断内连/外连技巧：通常肯定句式用内连，否定句式用外连；
判断主/从表技巧：否定词后所在的表就是从表；
判断筛选条件技巧：通常以从表的主键字段作为筛选字段。

## 6.SQL查询的基本原理

**单表查询**：根据WHERE条件过滤表中的记录，形成中间表（这个中间表对用户是不可见的）；然后根据SELECT的选择列选择相应的列进行返回最终结果。
**两表连接查询**：对两表求积（笛卡尔积）并用ON条件和连接连接类型进行过滤形成中间表；然后根据WHERE条件过滤中间表的记录，并根据SELECT指定的列返回查询结果。
**多表连接查询**：先对第一个和第二个表按照两表连接做查询，然后用查询结果和第三个表做连接查询，以此类推，直到所有的表都连接上为止，最终形成一个中间的结果表，然后根据WHERE条件过滤中间表的记录，并根据SELECT指定的列返回查询结果。

## 7.逻辑执行顺序

![image-20250225202445054](https://raw.githubusercontent.com/Dream-fennel/image-host/image/image-20250225202445054.png)

从这个顺序中我们不难发现，所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，而生成个虚拟表将作为下一个执行步骤的输入。
第一步：首先对from子句中的前两个表执行一个笛卡尔乘积,此时生成虚拟表vt1 (选择相对小的表做基础表)。
第二步：接下来便是应用on筛选器, on中的逻辑表达式将应用到vt1中的各个行,筛选出满足on逻辑表达式的行,生成虚拟表vt2。
第三步：如果是outer join那么这一步就将添加外部行；left outer jion就把左表在第二步中过滤的添加进来 ,如果是right outer join那么就将右表在第二步中过滤掉的行添加进来,这样生成虚拟表vt3。
第四步：如果from子句中的表数目多余两个表,那么就将vt3和第三个表连接从而计算笛卡尔乘积,生成虚拟表,该过程就是一个重复1-3的步骤,最终得到一个新的虚拟表vt3。
第五步：应用where筛选器,对上一步生产的虚拟表引用where筛选器,生成虚拟表vt4。
注意：where与on的区别:先执行on ,后执行where ; on是建立关联关系在生成临时表时候执行, where是在临时表生成后对数据进行筛选的。
第六步：group by子句将中的唯一的值组合成为一组,得到虚拟表vt5。如果应用了group by ,那么后面的所有步骤都只能得到的vt5的列或者是聚合函数( count、sum、avg等 )。原因在于最终的结果集中只为每个组包含一行。
第七步：应用avg或者sum选项,为vt5生成vt6。
第八步：应用having筛选器,生成vt7。having筛选器是第一个也是为唯一个应用到已分组数据的筛选器。
第九步：处理select子句。将vt7中的在select中出现的列筛选出来生成vt8。
第十步：应用distinct子句,对vt8进行去重生成vt9。
第十一步：应用order by子句。按照排序方式对vt9进行排序,此时返回的是一个游标,而不是虚拟表。
第十二步：应用limit选项。生成vt10返回结果给请求者即用户。

# 面试

内连接与外连接的区别？
1.语法不同：
内连接用inner join 命令；
外连接用left/right outer join 命令。
2.查询的内容不同：
内连接查询的是两个表都能匹配到的数据；
外连接查询的是主表中的全部内容
+从表中能匹配到的内容+从表中匹配不到的内容以null填充。

左外连接与右外连接的区别？
1.语法不同：
左外连接使用left outer join 命令；
右外连接使用right outer join 命令。
2.主从表位置不同：
左外连接主表在左边，从表在右边；
右外连接主表在右边，从表在左边。

4.如何判断使用内连接还是外连接呢？
内连接：通常需求为肯定句式；
外连接：通常需求为否定句式。
还有就是需求中有明确表达查询某个表的全部数据。

6.如何判断筛选条件？
通常筛选从表的主键为空的条件。

# 2.26 子查询

## 1.子查询语法

​	SQL语句（select语句（select语句（...）））；

## 2.子查询分类

**根据子查询返回的结果进行分类**。
标量子查询：一行一列。子查询返回的值是一行一列
列子查询：一列多行
行子查询：一行多列
表级子查询：多行多列。

## 3.子查询位置：

放在不同的位置，充当不同的角色，常见的子查询类型有哪些？
select （子查询）：子查询充当查询内容。（标量子查询）
from （子查询）：子查询充当数据源。（表级子查询）
where （子查询）：子查询充当筛选条件。（标量/列/行子查询）
having （子查询）：子查询充当筛选条件。（标量/列/行子查询）

## 4.子查询注意事项

子查询可以嵌套多层，但每一层需要用小括号括起来。

## 5.标量子查询

```sql
常用 主查询 where 条件 =（子查询）
```

## 练习

```sql
#查询王小明同班级的学生信息
#1.查询王小明所在班级
#2.查询学生信息
SELECT *
FROM students
WHERE classid =
	(SELECT classid
	FROM students
	WHERE NAME = '王小明');
#查询年龄比李晓红大的学生信息
#1.查询李晓红的年龄
#2.查询信息
SELECT *
FROM students
WHERE age>
	(SELECT age
	FROM students
	WHERE NAME = '李晓红');
#查询mysql班的学生信息
#查看mysql班的班级号
#查询学生信息
#方法1，子查询
SELECT *
FROM students
WHERE classid =
	(SELECT id
	FROM class
	WHERE NAME = 'MySQL班');
#方法2，连表
SELECT students.*
FROM students
INNER JOIN class
ON students.classid = class.id 
WHERE class.name = 'MySQL班';

#查询女生的年龄以及男生的平均年龄
SELECT age 女生年龄,
	(SELECT AVG(age)
	FROM students
	WHERE sex = '男') 男生的平均年龄
FROM students
WHERE sex = '女';

#查询班级人数比1号学生所在班级人数多的班级编号与人数
#1.1号学生所在班级号
#2.1号所在班级的人数
#3.查询班级编号与人数
SELECT classid,COUNT(*)
FROM students
GROUP BY classid
HAVING COUNT(*)>
	(SELECT COUNT(*)
	FROM students
	WHERE classid = 
		(SELECT classid
		FROM students
		WHERE id = 1));
```

## 6.列子查询

```sql
常用   
主查询 where 条件 in(子查询)
主查询 where 条件 =any(子查询)
主查询 where 条件 !=all(子查询) 
```

**注意**：any和all只能用于子查询里面，不能用于普通查询。

==any和all括号里面必须是SQL语句==

**总结**：

- <any时，小于最大的即可；

- any时，大于最小的即可；
- <all时，小于最小的；
- all时，大于最大的。

```sql
#查询与学生编号为1，3班级相同的学生信息
#查询学生编号为1，3的班级编号
#查询学生信息
SELECT *
FROM students
WHERE classid = ANY 
	(SELECT classid
	FROM students
	WHERE id = 1 OR id = 3);
#查询与学生编号为1，3班级相同的学生信息
SELECT *
FROM students
WHERE classid IN
	(SELECT classid
	FROM students
	WHERE id IN (1,3));
#any不能用在普通查询

#查询年龄比1班任意年龄小的学生信息
#1.查询1班的年龄N
#2.查询年龄比1班任意N小的学生信息
SELECT *
FROM students
WHERE age <ANY
	(SELECT age
	FROM students
	WHERE classid = 1);
#查询年龄比1班所有年龄小的学生信息
#1.查询1班的年龄N
#2.查询年龄比1班所有N小的学生信息
SELECT *
FROM students
WHERE age <ALL
	(SELECT age
	FROM students
	WHERE classid = 1);
#查询年龄比1班所有年龄小的学生信息
#使用标量子查询
SELECT *
FROM students
WHERE age <
	(SELECT MIN(age)
	FROM students
	WHERE classid=1);
```

## 7.行子查询

```sql
常见 主查询 where (条件1,条件2) = (行子查询)
```

```sql
#查询1班年龄最高的学生信息
SELECT *
FROM students
WHERE classid = 1 AND age=
	(SELECT MAX(age)
	FROM students
	WHERE classid = 1);
#1.查询1班的班级编号与最高年龄(X,Y)
SELECT classid,MAX(age) 
FROM students 
WHERE classid = 1;
#2.查询班级编号与学生年龄为(1,25)的学生信息
SELECT * 
FROM students 
WHERE (classid,age) = (1,25)
#3.用SQL语句替换(1,25)完成子查询
SELECT * 
FROM students 
WHERE (classid,age) = 
	(SELECT classid,MAX(age) 
	FROM students
	WHERE classid = 1);

```

## 8.表子查询

```sql 
常见 主查询 from （表子查询） as 表别名
```

```sql
#把每个班的平均年龄当作数据源，查询最低平均年龄
SELECT MIN(平均年龄) AS 最低平均年龄
FROM    (SELECT AVG(age) AS 平均年龄
	FROM students
	GROUP BY classid) AS a;
```

## 9.mysql 常见数据类型

数值型，字符型，日期型等。
数值型：表达数值的，如 小数，整数
	int 整型（整数），double 浮点型（小数）

字符型：表达字符串的，如 我好好好学习，月薪过万
	char 定长字符串，varchar 变长字符串

日期型：表达时间的，如 2025-02-26 16:25:00
	datetime 年月日时分秒

## 面试

char与varchar的区别？
char 存储的是固定长度字符串，
varchar 存储的是可变长度字符串；
所以 varchar 比 char 更节省空间。
但是，创建表时，varchar必须指定长度，否则会报错；
而char不指定长度不会报错，但有可能默认长度不能满足需求。
